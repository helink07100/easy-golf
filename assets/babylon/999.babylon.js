"use strict";(self.webpackChunkBABYLON=self.webpackChunkBABYLON||[]).push([[612,999],{5999:(e,t,n)=>{n.r(t),n.d(t,{Dispose:()=>b,DumpData:()=>S,DumpDataAsync:()=>m,DumpFramebuffer:()=>g,DumpTools:()=>x});var s=n(5616),r=n(4494),i=n(9848),a=n(4420),o=n(5476);n(6612);const d={positions:[1,1,-1,1,-1,-1,1,-1],indices:[0,1,2,0,2,3]};class f{constructor(e,t=d){this._fullscreenViewport=new r.L(0,0,1,1);const n=t.positions??d.positions,i=t.indices??d.indices;this.engine=e,this._vertexBuffers={[s.R.PositionKind]:new s.R(e,n,s.R.PositionKind,!1,!1,2)},this._indexBuffer=e.createIndexBuffer(i),this._onContextRestoredObserver=e.onContextRestoredObservable.add((()=>{this._indexBuffer=e.createIndexBuffer(i);for(const e in this._vertexBuffers)this._vertexBuffers[e]._rebuild()}))}setViewport(e=this._fullscreenViewport){this.engine.setViewport(e)}bindBuffers(e){this.engine.bindBuffers(this._vertexBuffers,this._indexBuffer,e)}applyEffectWrapper(e){this.engine.setState(!0),this.engine.depthCullingState.depthTest=!1,this.engine.stencilState.stencilTest=!1,this.engine.enableEffect(e._drawWrapper),this.bindBuffers(e.effect),e.onApplyObservable.notifyObservers({})}saveStates(){this._savedStateDepthTest=this.engine.depthCullingState.depthTest,this._savedStateStencilTest=this.engine.stencilState.stencilTest}restoreStates(){this.engine.depthCullingState.depthTest=this._savedStateDepthTest,this.engine.stencilState.stencilTest=this._savedStateStencilTest}draw(){this.engine.drawElementsType(0,0,6)}_isRenderTargetTexture(e){return void 0!==e.renderTarget}render(e,t=null){if(!e.effect.isReady())return;this.saveStates(),this.setViewport();const n=null===t?null:this._isRenderTargetTexture(t)?t.renderTarget:t;n&&this.engine.bindFramebuffer(n),this.applyEffectWrapper(e),this.draw(),n&&this.engine.unBindFramebuffer(n),this.restoreStates()}dispose(){const e=this._vertexBuffers[s.R.PositionKind];e&&(e.dispose(),delete this._vertexBuffers[s.R.PositionKind]),this._indexBuffer&&this.engine._releaseBuffer(this._indexBuffer),this._onContextRestoredObserver&&(this.engine.onContextRestoredObservable.remove(this._onContextRestoredObserver),this._onContextRestoredObserver=null)}}class p{get effect(){return this._drawWrapper.effect}set effect(e){this._drawWrapper.effect=e}constructor(e){let t;this.onApplyObservable=new i.cP;const n=e.uniformNames||[];e.vertexShader?t={fragmentSource:e.fragmentShader,vertexSource:e.vertexShader,spectorName:e.name||"effectWrapper"}:(n.push("scale"),t={fragmentSource:e.fragmentShader,vertex:"postprocess",spectorName:e.name||"effectWrapper"},this.onApplyObservable.add((()=>{this.effect.setFloat2("scale",1,1)})));const s=e.defines?e.defines.join("\n"):"";this._drawWrapper=new o.E(e.engine),e.useShaderStore?(t.fragment=t.fragmentSource,t.vertex||(t.vertex=t.vertexSource),delete t.fragmentSource,delete t.vertexSource,this.effect=e.engine.createEffect(t,e.attributeNames||["position"],n,e.samplerNames,s,void 0,e.onCompiled,void 0,void 0,e.shaderLanguage,e.extraInitializationsAsync)):(this.effect=new a.M(t,e.attributeNames||["position"],n,e.samplerNames,e.engine,s,void 0,e.onCompiled,void 0,void 0,void 0,e.shaderLanguage,e.extraInitializationsAsync),this._onContextRestoredObserver=e.engine.onContextRestoredObservable.add((()=>{this.effect._pipelineContext=null,this.effect._prepareEffect()})))}dispose(e=!1){this._onContextRestoredObserver&&(this.effect.getEngine().onContextRestoredObservable.remove(this._onContextRestoredObserver),this._onContextRestoredObserver=null),this.effect.dispose()}}var c=n(998),l=n(4867),h=n(6315);let u,v=null;async function g(e,t,n,s,r="image/png",i,a){const o=await n.readPixels(0,0,e,t);S(e,t,new Uint8Array(o.buffer),s,r,i,!0,void 0,a)}function m(e,t,n,s="image/png",r,i=!1,a=!1,o){return new Promise((d=>{S(e,t,n,(e=>d(e)),s,r,i,a,o)}))}function S(e,t,s,r,i="image/png",a,o=!1,d=!1,g){(async function(){return v||(v=new Promise(((e,t)=>{let s,r=null;const i={preserveDrawingBuffer:!0,depth:!1,stencil:!1,alpha:!0,premultipliedAlpha:!1,antialias:!1,failIfMajorPerformanceCaveat:!1};Promise.resolve().then(n.bind(n,6321)).then((({ThinEngine:a})=>{try{s=new OffscreenCanvas(100,100),r=new a(s,!1,i)}catch(e){s=document.createElement("canvas"),r=new a(s,!1,i)}h.q.Instances.pop(),h.q.OnEnginesDisposedObservable.add((e=>{r&&e!==r&&!r.isDisposed&&0===h.q.Instances.length&&b()})),r.getCaps().parallelShaderCompile=void 0;const o=new f(r);n.e(820).then(n.bind(n,9820)).then((({passPixelShader:n})=>{if(!r)return void t("Engine is not defined");const i=new p({engine:r,name:n.name,fragmentShader:n.shader,samplerNames:["textureSampler"]});u={canvas:s,engine:r,renderer:o,wrapper:i},e(u)}))})).catch(t)}))),await v})().then((n=>{if(n.engine.setSize(e,t,!0),s instanceof Float32Array){const e=new Uint8Array(s.length);let t=s.length;for(;t--;){const n=s[t];e[t]=Math.round(255*(0,l.OQ)(n))}s=e}const f=n.engine.createRawTexture(s,e,t,5,!1,!o,1);n.renderer.setViewport(),n.renderer.applyEffectWrapper(n.wrapper),n.wrapper.effect._bindTexture("textureSampler",f),n.renderer.draw(),d?c.S0.ToBlob(n.canvas,(e=>{const t=new FileReader;t.onload=e=>{const t=e.target.result;r&&r(t)},t.readAsArrayBuffer(e)}),i,g):c.S0.EncodeScreenshotCanvasData(n.canvas,r,i,a,g),f.dispose()}))}function b(){u?(u.wrapper.dispose(),u.renderer.dispose(),u.engine.dispose()):v?.then((e=>{e.wrapper.dispose(),e.renderer.dispose(),e.engine.dispose()})),v=null,u=null}const x={DumpData:S,DumpDataAsync:m,DumpFramebuffer:g,Dispose:b};c.S0.DumpData=S,c.S0.DumpDataAsync=m,c.S0.DumpFramebuffer=g},6612:(e,t,n)=>{n.r(t),n.d(t,{postprocessVertexShader:()=>i});const s="postprocessVertexShader",r="attribute vec2 position;uniform vec2 scale;varying vec2 vUV;const vec2 madd=vec2(0.5,0.5);\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_VERTEX_MAIN_BEGIN\nvUV=(position*madd+madd)*scale;gl_Position=vec4(position,0.0,1.0);\n#define CUSTOM_VERTEX_MAIN_END\n}";n(9610).l.ShadersStore[s]=r;const i={name:s,shader:r}}}]);